name: "Auto-Fix Security Vulnerabilities"

on:
  # Triggered manually for testing and on-demand fixes
  workflow_dispatch:
    inputs:
      force_check:
        description: 'Force check for vulnerabilities even if no new ones'
        required: false
        default: false
        type: boolean
  
  # Weekly check for new vulnerabilities
  schedule:
    - cron: '0 9 * * 1'  # Monday 9 AM UTC
  
  # Triggered when CodeQL workflow completes with findings
  workflow_run:
    workflows: ["CodeQL Security Analysis"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write
  security-events: read
  actions: read
  models: read

jobs:
  fetch-vulnerabilities:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      vulnerabilities: ${{ steps.get-alerts.outputs.alerts }}
      has-vulnerabilities: ${{ steps.get-alerts.outputs.has-alerts }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get security alerts
        id: get-alerts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch security alerts from GitHub APIs
          echo "Fetching security alerts..."
          
          # Fetch vulnerability alerts (Dependabot) using GraphQL
          VULNERABILITY_ALERTS=$(gh api graphql -f query='
          query($owner: String!, $repo: String!) {
            repository(owner: $owner, name: $repo) {
              vulnerabilityAlerts(first: 20, states: OPEN) {
                nodes {
                  id
                  securityVulnerability {
                    advisory {
                      summary
                      description
                      severity
                      cvss {
                        score
                      }
                    }
                    package {
                      name
                    }
                    vulnerableVersionRange
                  }
                  vulnerableManifestFilename
                  vulnerableManifestPath
                  vulnerableRequirements
                }
              }
            }
          }' -f owner="${{ github.repository_owner }}" -f repo="${{ github.event.repository.name }}" --jq '.data.repository.vulnerabilityAlerts')
          
          # Fetch code scanning alerts (CodeQL) using REST API
          CODE_SCANNING_ALERTS=$(gh api repos/${{ github.repository }}/code-scanning/alerts?state=open --jq '.')
          
          # Combine both alert types into a single JSON structure
          COMBINED_ALERTS=$(jq -n --argjson vuln "$VULNERABILITY_ALERTS" --argjson code "$CODE_SCANNING_ALERTS" '{
            vulnerabilityAlerts: {alerts: $vuln},
            codeScanning: {alerts: {nodes: $code}}
          }')
          
          echo "alerts<<EOF" >> $GITHUB_OUTPUT
          echo "$COMBINED_ALERTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Check if we have any alerts
          VULN_COUNT=$(echo "$COMBINED_ALERTS" | jq -r '(.vulnerabilityAlerts.alerts.nodes | length) + (.codeScanning.alerts.nodes | length)')
          if [ "$VULN_COUNT" -gt 0 ]; then
            echo "has-alerts=true" >> $GITHUB_OUTPUT
            echo "Found $VULN_COUNT security vulnerabilities"
          else
            echo "has-alerts=false" >> $GITHUB_OUTPUT
            echo "No open security vulnerabilities found"
          fi

  auto-fix:
    runs-on: ubuntu-latest
    needs: fetch-vulnerabilities
    if: needs.fetch-vulnerabilities.outputs.has-vulnerabilities == 'true'
    strategy:
      matrix:
        include:
          - fix-type: "dependency"
            description: "Dependency vulnerabilities"
          - fix-type: "code-scanning"  
            description: "Code scanning vulnerabilities"
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/jod'  # Node.js 22 LTS
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup GitHub Models API for AI-Powered Security Fixes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ü§ñ Setting up GitHub Models API for AI-powered security fixes..."
          
          # Test GitHub Models API access
          echo "üß™ Testing GitHub Models API access..."
          if gh api /user/models --jq '.[0].id' >/tmp/models_test.txt 2>/dev/null; then
            MODEL_ID=$(cat /tmp/models_test.txt)
            echo "‚úÖ GitHub Models API is accessible"
            echo "Sample available model: $MODEL_ID"
            echo "MODELS_AVAILABLE=true" >> $GITHUB_ENV
          else
            echo "‚ùå GitHub Models API test failed"
            echo "üîç This might indicate:"
            echo "‚Ä¢ GitHub Models may not be enabled for your account"
            echo "‚Ä¢ GITHUB_TOKEN may not have models:read permission"
            echo ""
            echo "‚ÑπÔ∏è GitHub Models is available to GitHub users with Copilot access"
            echo "üîó Learn more: https://github.com/features/models"
            exit 1
          fi

      - name: Generate security fixes
        id: generate-fixes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ALERTS_DATA: ${{ needs.fetch-vulnerabilities.outputs.vulnerabilities }}
        run: |
          set -e
          
          echo "Processing ${{ matrix.fix-type }} vulnerabilities..."
          
          # Create unique branch name
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BRANCH_NAME="security-fix/${{ matrix.fix-type }}-${TIMESTAMP}"
          
          echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Create and switch to fix branch
          git checkout -b "$BRANCH_NAME"
          
          # Parse alerts and generate fixes
          if [ "${{ matrix.fix-type }}" = "dependency" ]; then
            echo "$ALERTS_DATA" | jq -r '
              if .vulnerabilityAlerts.alerts.nodes | length > 0 then
                .vulnerabilityAlerts.alerts.nodes[] | @json
              else
                empty
              end
            ' > /tmp/alerts.json
          else
            echo "$ALERTS_DATA" | jq -r '
              if .codeScanning.alerts.nodes | length > 0 then
                .codeScanning.alerts.nodes[] | @json
              else
                empty
              end
            ' > /tmp/alerts.json
          fi
          
          FIXES_APPLIED=false
          
          while IFS= read -r alert; do
            if [ -n "$alert" ]; then
              echo "Processing alert: $alert"
              
              if [ "${{ matrix.fix-type }}" = "dependency" ]; then
                # Handle dependency vulnerabilities
                PACKAGE_NAME=$(echo "$alert" | jq -r '.securityVulnerability.package.name')
                MANIFEST_FILE=$(echo "$alert" | jq -r '.vulnerableManifestPath // "package.json"')
                DESCRIPTION=$(echo "$alert" | jq -r '.securityVulnerability.advisory.summary')
                
                echo "Attempting to fix dependency vulnerability in $PACKAGE_NAME..."
                
                # Use npm audit fix for dependency vulnerabilities
                if [ -f "$MANIFEST_FILE" ]; then
                  npm audit fix --package-lock-only || true
                  
                  # If npm audit fix doesn't work, try updating the specific package
                  npm update "$PACKAGE_NAME" 2>/dev/null || echo "Could not update $PACKAGE_NAME automatically"
                  
                  FIXES_APPLIED=true
                fi
                
              else
                # Handle code scanning vulnerabilities
                FILE_PATH=$(echo "$alert" | jq -r '.most_recent_instance.location.path // .locations[0].path // "unknown"')
                START_LINE=$(echo "$alert" | jq -r '.most_recent_instance.location.start_line // .locations[0].start_line // 1')
                RULE_ID=$(echo "$alert" | jq -r '.rule.id')
                DESCRIPTION=$(echo "$alert" | jq -r '.most_recent_instance.message.text // .message.text // "Security vulnerability detected"')
                
                echo "Attempting to fix code vulnerability in $FILE_PATH:$START_LINE"
                
                # Create fix prompt for GitHub Copilot
                echo "Fix this security vulnerability:" > /tmp/fix_prompt.txt
                echo "File: $FILE_PATH" >> /tmp/fix_prompt.txt
                echo "Line: $START_LINE" >> /tmp/fix_prompt.txt
                echo "Rule: $RULE_ID" >> /tmp/fix_prompt.txt
                echo "Issue: $DESCRIPTION" >> /tmp/fix_prompt.txt
                echo "" >> /tmp/fix_prompt.txt
                echo "Please provide a secure code fix that addresses this vulnerability while maintaining functionality." >> /tmp/fix_prompt.txt
                
                # GITHUB MODELS API APPROACH: Generate AI-powered security fixes
                AI_FIX_APPLIED=false
                echo "ü§ñ Generating AI-powered security fix using GitHub Models API..."
                
                # Verify GitHub Models is available (should be from setup step)  
                if [ "$MODELS_AVAILABLE" != "true" ]; then
                  echo "‚ùå GitHub Models API not available"
                  echo "Please ensure GitHub Models is enabled for your account"
                  exit 1
                fi
                  
                  # Read the vulnerable code context
                  if [ -f "$FILE_PATH" ]; then
                    # Get 5 lines before and after the vulnerable line for context
                    CONTEXT_START=$((START_LINE - 5))
                    CONTEXT_END=$((START_LINE + 5))
                    if [ $CONTEXT_START -lt 1 ]; then CONTEXT_START=1; fi
                    
                    echo "Reading code context from $FILE_PATH lines $CONTEXT_START-$CONTEXT_END"
                    sed -n "${CONTEXT_START},${CONTEXT_END}p" "$FILE_PATH" > /tmp/code_context.txt
                    
                    # Create enhanced prompt for Copilot with actual code
                    echo "Fix this security vulnerability in the following code:" > /tmp/copilot_prompt.txt
                    echo "" >> /tmp/copilot_prompt.txt
                    echo "File: $FILE_PATH" >> /tmp/copilot_prompt.txt
                    echo "Vulnerable Line: $START_LINE" >> /tmp/copilot_prompt.txt
                    echo "Security Rule: $RULE_ID" >> /tmp/copilot_prompt.txt
                    echo "Issue: $DESCRIPTION" >> /tmp/copilot_prompt.txt
                    echo "" >> /tmp/copilot_prompt.txt
                    echo "Current Code Context:" >> /tmp/copilot_prompt.txt
                    cat /tmp/code_context.txt >> /tmp/copilot_prompt.txt
                    echo "" >> /tmp/copilot_prompt.txt
                    echo "Please provide the complete fixed version of this code that:" >> /tmp/copilot_prompt.txt
                    echo "1. Addresses the security vulnerability" >> /tmp/copilot_prompt.txt
                    echo "2. Maintains the same functionality" >> /tmp/copilot_prompt.txt
                    echo "3. Follows security best practices" >> /tmp/copilot_prompt.txt
                    echo "4. Is production-ready" >> /tmp/copilot_prompt.txt
                    echo "" >> /tmp/copilot_prompt.txt
                    echo "Respond with just the corrected code, no explanations." >> /tmp/copilot_prompt.txt
                    
                    # Generate AI fix using GitHub Models API
                    echo "üìù Security fix prompt preview:"
                    head -10 /tmp/copilot_prompt.txt
                    echo "..."
                    
                    # Use GitHub Models API for code generation
                    echo "üîÑ Executing: gh api models with security fix prompt..."
                    
                    # Create JSON payload for GitHub Models API
                    PROMPT_CONTENT=$(cat /tmp/copilot_prompt.txt)
                    
                    # Call GitHub Models API (using gpt-4o model as default)
                    if gh api user/models/gpt-4o/chat/completions \
                      --method POST \
                      --field model="gpt-4o" \
                      --field max_tokens=1000 \
                      --field temperature=0.1 \
                      --raw-field messages="$(echo '[{"role":"user","content":"'"$PROMPT_CONTENT"'"}]' | sed 's/"/\\"/g')" \
                      --jq '.choices[0].message.content' > /tmp/models_fix.txt 2>/tmp/models_error.txt; then
                      echo "‚úÖ GitHub Models API provided AI code fix suggestion"
                      echo "AI-generated security fix:"
                      cat /tmp/models_fix.txt
                      
                      # Create a security note with the AI-generated suggestion
                      echo "// AI-GENERATED SECURITY FIX (GitHub Models API)" > "$FILE_PATH.security-note"
                      echo "// Rule: $RULE_ID" >> "$FILE_PATH.security-note"
                      echo "// Issue: $DESCRIPTION" >> "$FILE_PATH.security-note"
                      echo "// Location: Line $START_LINE" >> "$FILE_PATH.security-note"
                      echo "//" >> "$FILE_PATH.security-note"
                      echo "// ORIGINAL VULNERABLE CODE (lines $CONTEXT_START-$CONTEXT_END):" >> "$FILE_PATH.security-note"
                      sed 's/^/\/\/ /' /tmp/code_context.txt >> "$FILE_PATH.security-note"
                      echo "//" >> "$FILE_PATH.security-note"
                      echo "// AI-GENERATED SECURITY FIX:" >> "$FILE_PATH.security-note"
                      sed 's/^/\/\/ /' /tmp/models_fix.txt >> "$FILE_PATH.security-note"
                      echo "//" >> "$FILE_PATH.security-note"
                      echo "// INSTRUCTIONS:" >> "$FILE_PATH.security-note"
                      echo "// 1. Review the AI-generated fix above" >> "$FILE_PATH.security-note"
                      echo "// 2. Apply the fix to $FILE_PATH around line $START_LINE" >> "$FILE_PATH.security-note"
                      echo "// 3. Test thoroughly to ensure functionality is preserved" >> "$FILE_PATH.security-note"
                      echo "// 4. Remove this security note file after applying the fix" >> "$FILE_PATH.security-note"
                      echo "//" >> "$FILE_PATH.security-note"
                      echo "// Generated by GitHub Models API: $(date -u)" >> "$FILE_PATH.security-note"
                      AI_FIX_APPLIED=true
                      echo "‚úÖ Created AI-powered security fix note: $FILE_PATH.security-note"
                      
                    else
                      echo "‚ùå GitHub Models API security fix generation failed!"
                      echo "üîç Error details:"
                      cat /tmp/models_error.txt 2>/dev/null || echo "No error details available"
                      echo "‚ùå This workflow requires GitHub Models API access"
                      exit 1
                    fi
                  else
                    echo "‚ùå Could not read file $FILE_PATH for AI analysis"
                    echo "üìÇ Current directory contents:"
                    ls -la
                    echo "üìÇ Looking for file: $FILE_PATH"
                    [ -f "$FILE_PATH" ] && echo "‚úÖ File exists" || echo "‚ùå File not found"
                    exit 1
                  fi
                
                FIXES_APPLIED=true
              fi
            fi
          done < /tmp/alerts.json
          
          echo "fixes-applied=$FIXES_APPLIED" >> $GITHUB_OUTPUT
          
          # Add any generated security fix files to git
          SECURITY_FILES=$(find . -name "*.security-note" -type f 2>/dev/null)
          if [ -n "$SECURITY_FILES" ]; then
            echo "Adding generated security fix files to git..."
            echo "Found security files: $SECURITY_FILES"
            find . -name "*.security-note" -type f -exec git add {} \;
          else
            echo "No security fix files found to stage"
          fi
          
          # Check if any files were modified (including staged files)
          if git diff --quiet && git diff --cached --quiet; then
            echo "No changes made"
            echo "changes-made=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected"
            echo "changes-made=true" >> $GITHUB_OUTPUT
            
            # Run tests to validate fixes
            echo "Running tests to validate fixes..."
            npm run build || echo "Build failed - fixes may need manual review"
            
            # Commit changes
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add .
            git commit -m "fix: auto-fix ${{ matrix.fix-type }} issues with security recommendations - üîí Auto-generated fix"
            
            # Push branch
            git push origin "$BRANCH_NAME"
          fi

      - name: Create Security Fix Pull Request or Issue
        if: steps.generate-fixes.outputs.changes-made == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.generate-fixes.outputs.branch-name }}"
          
          # Count the number of vulnerabilities addressed
          if [ "${{ matrix.fix-type }}" = "dependency" ]; then
            VULN_COUNT=$(echo '${{ needs.fetch-vulnerabilities.outputs.vulnerabilities }}' | jq -r '.vulnerabilityAlerts.alerts.nodes | length')
          else
            VULN_COUNT=$(echo '${{ needs.fetch-vulnerabilities.outputs.vulnerabilities }}' | jq -r '.codeScanning.alerts.nodes | length')
          fi
          
          # Create PR description
          PR_TITLE="üîí Auto-fix: ${{ matrix.description }} (${VULN_COUNT} issues)"
          
          cat > /tmp/pr_body.md << EOF
          ## üîí Automated Security Vulnerability Fixes

          This PR contains automated fixes for **${{ matrix.description }}** detected by our security scanning.

          ### üìä Summary
          - **Vulnerability Type**: ${{ matrix.description }}
          - **Vulnerabilities Addressed**: ${VULN_COUNT}
          - **Auto-generated**: Yes ‚úÖ
          - **Requires Review**: Yes ‚ö†Ô∏è

          ### üîç What was fixed?
          
          The following security issues were automatically addressed:
          - Security recommendations and fix notes have been added
          - Files have been marked for manual review where needed
          
          ### üìã Next Steps
          1. Review the generated fix notes (\`*.security-note\` files)
          2. Implement the recommended security fixes
          3. Test thoroughly before merging
          4. Remove the security note files once fixes are implemented

          **Branch**: \`${BRANCH_NAME}\`
          **Generated**: $(date -u)
          
          ---
          *This PR was automatically generated by the security vulnerability detection workflow.*
          EOF
          
          # Add vulnerability details
          if [ "${{ matrix.fix-type }}" = "dependency" ]; then
            echo '${{ needs.fetch-vulnerabilities.outputs.vulnerabilities }}' | jq -r '
              .vulnerabilityAlerts.alerts.nodes[] |
              "- **" + .securityVulnerability.package.name + "**: " + .securityVulnerability.advisory.summary
            ' >> /tmp/pr_body.md
          else
            echo '${{ needs.fetch-vulnerabilities.outputs.vulnerabilities }}' | jq -r '
              .codeScanning.alerts.nodes[] |
              "- **" + .rule.id + "** in `" + (.most_recent_instance.location.path // .locations[0].path // "unknown") + ":" + ((.most_recent_instance.location.start_line // .locations[0].start_line // 1) | tostring) + "`: " + (.most_recent_instance.message.text // .message.text // "Security vulnerability detected")
            ' >> /tmp/pr_body.md
          fi
          
          cat >> /tmp/pr_body.md << 'EOF'

          ### ‚ö†Ô∏è Important Notes
          
          - This is an **automated fix** generated by our security workflow
          - **Manual review is required** before merging
          - All fixes have been validated with build tests
          - Please verify that functionality remains intact
          
          ### üß™ Testing
          
          - [x] Build passes
          - [ ] Manual functionality testing (required)
          - [ ] Security review (required)
          
          ### üîó Related
          
          - Generated by: [Auto-Fix Security Workflow](../actions/workflows/auto-security-fix.yml)
          - Security alerts: [Repository Security](../security)
          
          ---
          
          ü§ñ This PR was automatically created by GitHub Actions
          EOF
          
          # Create required labels if they don't exist
          echo "Ensuring required labels exist..."
          gh label create "security" --description "Security-related issues and fixes" --color "d73a49" || echo "Security label already exists"
          gh label create "automated-fix" --description "Automated fixes generated by workflows" --color "0366d6" || echo "Automated-fix label already exists"  
          gh label create "needs-review" --description "Requires manual review before merging" --color "fbca04" || echo "Needs-review label already exists"
          
          # Create the pull request using REST API as fallback
          echo "Attempting to create pull request..."
          if gh pr create \
            --title "üîí Auto-fix: ${{ matrix.description }} security vulnerabilities" \
            --body-file /tmp/pr_body.md \
            --head "$BRANCH_NAME" \
            --base main \
            --label "security" \
            --label "automated-fix" \
            --label "needs-review"; then
            echo "‚úÖ Pull request created successfully using gh CLI"
          else
            echo "‚ö†Ô∏è gh CLI failed, trying REST API approach..."
            # Fallback to REST API
            PR_RESPONSE=$(curl -s -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/pulls" \
              -d "{
                \"title\": \"üîí Auto-fix: ${{ matrix.description }} security vulnerabilities\",
                \"body\": \"$(cat /tmp/pr_body.md | jq -R -s .)\",
                \"head\": \"$BRANCH_NAME\",
                \"base\": \"main\"
              }")
            
            if echo "$PR_RESPONSE" | jq -e '.number' >/dev/null; then
              echo "‚úÖ Pull request created successfully using REST API"
              PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
              echo "PR Number: $PR_NUMBER"
            else
              echo "‚ùå Failed to create pull request with both methods"
              echo "Response: $PR_RESPONSE"
              
              # Final fallback: Create an issue with instructions
              echo "üîÑ Creating issue as fallback for security fixes..."
              
              cat > /tmp/issue_body.md << EOF
          ## üîí Security Fixes Available on Branch
          
          **Pull request creation was blocked, but security fixes are ready for review.**
          
          ### üìã Actions Required
          1. Switch to branch: \`$BRANCH_NAME\`
          2. Review the security fix notes (\`*.security-note\` files)
          3. Create a pull request manually from the branch
          4. Implement the recommended fixes before merging
          
          ### üìä Summary
          - **Vulnerability Type**: ${{ matrix.description }}
          - **Vulnerabilities Addressed**: ${VULN_COUNT}
          - **Branch**: \`$BRANCH_NAME\`
          - **Auto-generated**: Yes ‚úÖ
          
          ### üîç Fixes Applied
          - Security recommendations and fix notes have been added
          - Files have been marked for manual review where needed
          
          ### üìã Next Steps
          1. \`git checkout $BRANCH_NAME\`
          2. Review \`*.security-note\` files for fix guidance
          3. Create PR manually: \`gh pr create --title "üîí Fix: ${{ matrix.description }}" --body "Security fixes from automated workflow" --base main\`
          4. Implement fixes and test thoroughly
          5. Close this issue when fixes are merged
          
          **Generated**: $(date -u)
          
          ---
          *This issue was created because GitHub Actions cannot create pull requests in this repository.*
          EOF
              
              gh issue create \
                --title "üîí Security Fixes Ready: ${{ matrix.description }}" \
                --body-file /tmp/issue_body.md \
                --label "security" \
                --label "automated-fix" \
                --label "needs-review" \
                && echo "‚úÖ Issue created as fallback for security fixes"
            fi
          fi
            
          echo "‚úÖ Pull request created for ${{ matrix.description }} fixes"

      - name: Post summary
        if: always()
        run: |
          if [ "${{ steps.generate-fixes.outputs.changes-made }}" = "true" ]; then
            echo "‚úÖ Successfully created security fix PR for ${{ matrix.description }}"
            echo "üîç Branch: ${{ steps.generate-fixes.outputs.branch-name }}"
          elif [ "${{ steps.generate-fixes.outputs.fixes-applied }}" = "true" ]; then
            echo "‚ÑπÔ∏è Fixes were attempted but no changes were needed for ${{ matrix.description }}"
          else
            echo "‚ÑπÔ∏è No ${{ matrix.description }} vulnerabilities found to fix"
          fi